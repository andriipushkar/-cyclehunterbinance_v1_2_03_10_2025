# Детальний опис команд

## Загальна структура

Основна точка входу — `cli_monitor/main.py`. Вона використовує стандартну бібліотеку `argparse` для створення ієрархічної структури команд:

*   `python3 -m cli_monitor <command> <subcommand> [options]`

Головні команди (модулі):
1.  `balance` - все, що пов'язано з балансами гаманців.
2.  `arbitrage` - інструменти для пошуку та аналізу арбітражних можливостей.

---

### 1. Команди для роботи з балансом (`balance`)

Логіка цих команд знаходиться в `cli_monitor/balance/main.py` та `cli_monitor/balance/commands.py`.

#### 1.1. `balance get`

*   **Команда:** `python3 -m cli_monitor balance get`
*   **Що робить:** Робить **одноразовий** запит до Binance API для отримання поточних балансів.
*   **Детальний опис:**
    1.  Викликається функція `monitor.get_balances()` з класу `BalanceMonitor`.
    2.  Ця функція послідовно викликає методи клієнта Binance для отримання балансів:
        *   **Spot-гаманця:** `client.get_account()`
        *   **Futures-гаманця:** `client.futures_account_balance()`
        *   **Earn-гаманця (Simple Earn):** `client.get_simple_earn_account()`
    3.  Для кожного гаманця відбираються тільки ті активи, кількість яких більша за нуль.
    4.  Результат виводиться в консоль у вигляді таблиці, де вказано гаманець, актив та його кількість.
*   **Функціонал:** Надання швидкого знімка поточних активів на різних гаманцях.

#### 1.2. `balance monitor`

*   **Команда:** `python3 -m cli_monitor balance monitor`
*   **Що робить:** Запускає **безперервний моніторинг** балансів, оновлюючи дані кожну хвилину.
*   **Детальний опис:**
    1.  Викликається функція `monitor.monitor_balances()`.
    2.  Запускається нескінченний цикл (`while True`).
    3.  Всередині циклу виконується та ж логіка, що і в команді `balance get` (отримання та вивід балансів Spot, Futures, Earn).
    4.  Після кожного оновлення програма "засинає" на 60 секунд (`time.sleep(60)`).
    5.  Процес можна зупинити комбінацією клавіш `Ctrl+C`.
*   **Функціонал:** Постійне відстеження стану балансів у реальному часі без необхідності перезапускати команду.

---

### 2. Команди для арбітражу (`arbitrage`)

Логіка цих команд знаходиться в `cli_monitor/arbitrage/main.py` та відповідних модулях (`cycle_finder.py`, `backtester.py` і т.д.).

#### 2.1. `arbitrage generate-whitelist`

*   **Команда:** `python3 -m cli_monitor arbitrage generate-whitelist`
*   **Що робить:** Генерує "білий список" (`whitelist.json`) — список найліквідніших монет та торгових пар.
*   **Детальний опис:**
    1.  Викликається функція `generate_whitelist()` з `whitelist_generator.py`.
    2.  З конфігураційного файлу `config.json` завантажуються критерії:
        *   `whitelist_base_coins`: список базових монет (напр., USDT, BTC, ETH).
        *   `whitelist_min_volume_usd`: мінімальний 24-годинний обсяг торгів в USD.
        *   `whitelist_top_n_pairs`: скільки найкращих пар відібрати.
    3.  Робляться запити до Binance API для отримання інформації про всі торгові пари (`exchange_info`) та їх 24-годинну статистику (`24h_ticker`).
    4.  Проводиться фільтрація:
        *   Пара має бути активною (`status == 'TRADING'`).
        *   Хоча б одна з монет пари має бути в списку `whitelist_base_coins`.
        *   Обсяг торгів пари має перевищувати `whitelist_min_volume_usd`.
    5.  Відфільтровані пари сортуються за обсягом торгів (від більшого до меншого), і вибираються `top_n_pairs` найкращих.
    6.  З цих топ-пар збираються унікальні монети (`whitelist_assets`) та самі пари (`whitelist_pairs`), які зберігаються у файл `configs/whitelist.json`.
*   **Функціонал:** Створення списку надійних та ліквідних активів для подальшого пошуку арбітражних циклів, що зменшує "шум" і підвищує якість аналізу.

#### 2.2. `arbitrage generate-blacklist`

*   **Команда:** `python3 -m cli_monitor arbitrage generate-blacklist`
*   **Що робить:** Генерує "чорний список" (`blacklist.json`) — список найменш ліквідних монет.
*   **Детальний опис:**
    1.  Викликається функція `generate_blacklist()` з `blacklist_generator.py`.
    2.  Завантажується `whitelist.json`, щоб його пари не потрапили до чорного списку.
    3.  З `config.json` береться параметр `blacklist_bottom_n_pairs` (кількість найгірших пар для списку).
    4.  Відбираються всі торгові пари, що не входять до білого списку і мають хоч якийсь обсяг торгів.
    5.  Пари сортуються за обсягом (від меншого до більшого), і вибираються `blacklist_bottom_n_pairs` найгірших.
    6.  Монети та пари з цього списку зберігаються у `configs/blacklist.json`.
*   **Функціонал:** Відсіювання неліквідних активів, які можуть створювати помилкові арбітражні сигнали.

#### 2.3. `arbitrage find-cycles`

*   **Команда:** `python3 -m cli_monitor arbitrage find-cycles [--strategy <strategy>]`
*   **Що робить:** Знаходить усі можливі замкнені ланцюжки обміну (цикли) і зберігає їх у `possible_cycles.json`.
*   **Детальний опис:**
    1.  Викликається метод `run()` класу `CycleFinder`.
    2.  **Вибір монет:** Залежно від прапора `--strategy` (за замовчуванням `liquidity`):
        *   `liquidity`: використовуються монети з попередньо згенерованого `whitelist.json`.
        *   `volatility`: відбираються най більш волатильні монети за останні 24 години.
    3.  **Побудова графа:** На основі вибраних монет та інформації про торгові пари з Binance будується граф, де вершини — це монети, а ребра — можливість прямого обміну між ними.
    4.  **Пошук циклів:** За допомогою алгоритму пошуку в глибину (DFS) знаходяться всі прості цикли, що починаються і закінчуються в базовій валюті (напр., `USDT -> BTC -> ETH -> USDT`). Довжина циклу обмежується параметром `max_cycle_length` з конфігурації.
    5.  Знайдені цикли зберігаються у файли `configs/possible_cycles.json` та `configs/possible_cycles.txt`.
*   **Функціонал:** Підготовка "карти" всіх теоретично можливих арбітражних шляхів для подальшого аналізу їх прибутковості.

#### 2.4. `arbitrage run-monitor`

*   **Команда:** `python3 -m cli_monitor arbitrage run-monitor`
*   **Що робить:** Запускає **безперервний моніторинг прибутковості** циклів, знайдених на попередньому кроці.
*   **Детальний опис:**
    1.  Викликається асинхронна функція `profit_calculator_main()`.
    2.  З файлу `possible_cycles.json` завантажуються всі знайдені цикли.
    3.  Запускається `ProfitMonitor`, який у реальному часі через WebSocket підписується на оновлення цін (`bookTicker`) для всіх торгових пар, що беруть участь у циклах.
    4.  При кожному оновленні ціни `ProfitMonitor` миттєво перераховує потенційний прибуток для всіх циклів, яких це стосується.
    5.  Якщо розрахований прибуток перевищує поріг `min_profit_threshold` з конфігурації, інформація про цей цикл (назва, час, прибуток, ціни) записується в лог-файл у папці `output/profits`.
*   **Функціонал:** Основний інструмент для виявлення реальних арбітражних можливостей у реальному часі.

#### 2.5. `arbitrage start-bot`

*   **Команда:** `python3 -m cli_monitor arbitrage start-bot`
*   **Що робить:** Запускає повноцінного арбітражного бота, який об'єднує всі кроки: від генерації списків до симуляції угод.
*   **Детальний опис:**
    1.  Викликається `start_bot_main()`, яка запускає `ArbitrageBot`.
    2.  **Крок 1: Налаштування.** Бот автоматично виконує послідовність дій:
        *   `generate-whitelist`
        *   `generate-blacklist`
        *   `find-cycles`
    3.  **Крок 2: Моніторинг.** Запускається `ProfitMonitor` (як у `run-monitor`), але замість запису в лог, він відправляє прибуткові цикли в спеціальну чергу (`asyncio.Queue`).
    4.  **Крок 3: Симуляція угоди ("Dry Run").**
        *   Основний цикл бота очікує на прибуткові цикли з черги.
        *   Коли надходить цикл, `TradeExecutor` перевіряє його на ліквідність (чи не занадто малий обсяг торгів у пар).
        *   Далі він симулює виконання кожної угоди в циклі, аналізуючи **стакан ордерів** (`order_book`), щоб розрахувати реальну ціну виконання з урахуванням прослизання (`slippage`).
        *   Результати симуляції (розрахований фінальний баланс) детально логуються в консоль та записуються у CSV-файл в папці `output/trades`.
*   **Функціонал:** Найбільш комплексна команда, що емулює повний цикл роботи арбітражної стратегії: від аналізу ринку до імітації реальних торгів з урахуванням ринкової ліквідності.

#### 2.6. `arbitrage backtest <start_date> <end_date>`

*   **Команда:** `python3 -m cli_monitor arbitrage backtest 2023-01-01 2023-01-31`
*   **Що робить:** Тестує арбітражну стратегію на **історичних даних**.
*   **Детальний опис:**
    1.  Викликається клас `Backtester` з вказаним діапазоном дат.
    2.  З файлу `possible_cycles.json` завантажуються цикли.
    3.  Для всіх торгових пар, що беруть участь у циклах, з Binance завантажуються **історичні похвилинні дані про ціни** (K-лінії) за вказаний період.
    4.  Дані вирівнюються похвилинно, створюючи "знімки" цін для всього ринку на кожну хвилину в минулому.
    5.  Програма ітерує по кожному такому "знімку", розраховуючи прибутковість кожного циклу з історичними цінами.
    6.  Якщо в якусь хвилину цикл був би прибутковим (вище за `min_profit_threshold`), результат записується в лог-файл `logs/backtest_results.log`.
*   **Функціонал:** Дозволяє оцінити ефективність поточної конфігурації та знайдених циклів на минулих даних, щоб зрозуміти, чи могла б стратегія бути прибутковою.