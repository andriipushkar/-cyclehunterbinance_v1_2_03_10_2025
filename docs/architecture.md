# Архітектура проекту CycleHunter

Цей документ описує архітектуру CLI-інструменту CycleHunter, його основні компоненти та їхню взаємодію.

## Загальна концепція

Проект побудований за модульним принципом. Основна логіка розділена на дві великі частини:

1.  **Balance**: Модуль для моніторингу балансів.
2.  **Arbitrage**: Модуль для пошуку, аналізу та симуляції арбітражних можливостей.

Центральною командою, що демонструє всю потужність інструменту, є `arbitrage start-bot`. Архітектурна схема нижче ілюструє саме її життєвий цикл.

## Схема архітектури

Схема показує потік даних та взаємодію компонентів при запуску арбітражного бота.

```mermaid
graph TD
    subgraph "Користувач"
        A[CLI: python3 -m cli_monitor arbitrage start-bot]
    end

    subgraph "Рівень Оркестрації"
        B[ArbitrageBot]
    end

    subgraph "Крок 1: Налаштування (Setup)"
        C[generate_whitelist] --> D[configs/whitelist.json]
        E[generate_blacklist] --> F[configs/blacklist.json]
        G[CycleFinder] -- використовує whitelist --> H[configs/possible_cycles.json]
    end

    subgraph "Крок 2: Моніторинг в реальному часі"
        I[ProfitMonitor] -- підписка через WebSocket --> J[Binance Real-time Prices]
        H --> I
        K[asyncio.Queue 
(Черга прибуткових циклів)]
    end

    subgraph "Крок 3: Симуляція угоди (Dry Run)"
        L[TradeExecutor]
        M[Binance Order Book API 
(API стакану ордерів)]
        N[output/trades/*.csv 
(Логи симуляцій)]
    end

    A --> B

    B -- запускає --> C
    B -- запускає --> E
    B -- запускає --> G

    I -- знаходить прибутковий цикл --> K
    B -- отримує цикл з черги --> L

    L -- запит актуального стакану --> M
    L -- записує результат --> N
```

## Опис компонентів та процесу

1.  **Користувач** запускає бота через команду в терміналі.

2.  **ArbitrageBot** (`bot.py`) - це головний клас-оркестратор. Він ініціалізує та координує роботу всіх інших компонентів.

3.  **Етап налаштування:**
    *   `generate_whitelist` (`whitelist_generator.py`): Аналізує ринок і створює "білий список" найбільш ліквідних активів.
    *   `generate_blacklist` (`blacklist_generator.py`): Створює "чорний список" найменш ліквідних активів для їх ігнорування.
    *   `CycleFinder` (`cycle_finder.py`): На основі "білого списку" будує граф торгових пар і знаходить усі теоретично можливі арбітражні цикли. Результат зберігається у `possible_cycles.json`.

4.  **Етап моніторингу:**
    *   `ProfitMonitor` (`profit_calculator.py`): Завантажує знайдені цикли. Він підписується на потік цін з Binance API через **WebSocket**. Це дозволяє отримувати оновлення миттєво.
    *   При кожному оновленні ціни `ProfitMonitor` перераховує прибутковість циклів. Якщо прибуток перевищує заданий поріг, він кладе цей "прибутковий цикл" в чергу (`asyncio.Queue`).

5.  **Етап симуляції угоди:**
    *   `ArbitrageBot` постійно слухає чергу. Як тільки там з'являється новий цикл, він передає його до `TradeExecutor`.
    *   `TradeExecutor` (`bot.py`):
        1.  **Перевіряє ліквідність**: робить додатковий запит, щоб переконатися, що обсяги торгів по парах у циклі достатні.
        2.  **Аналізує стакан ордерів**: робить API-запит до **стакану ордерів** (`Order Book`), щоб зрозуміти реальну глибину ринку.
        3.  **Симулює угоду**: розраховує середню ціну виконання з урахуванням можливого **прослизання** (slippage).
        4.  **Логує результат**: записує детальний звіт про симуляцію, включаючи розрахований реальний прибуток, у CSV-файл в папці `output/trades`.

Ця архітектура дозволяє ефективно розділити завдання: швидкий пошук можливостей у реальному часі (`ProfitMonitor`) та більш глибокий, але повільний аналіз з симуляцією (`TradeExecutor`), який виконується тільки тоді, коли знайдено дійсно варту уваги можливість.
