# Технічне Завдання: Розробка Арбітражного Бота "Tri-Catcher"

## 1. Загальні положення

**Назва проєкту:** Tri-Catcher

**Мета:** Розробка програмного забезпечення (бота) для автоматичного виявлення та розрахунку прибутковості можливостей трикутного арбітражу на криптовалютній біржі Binance.

**Основна технологія:** Python 3.9+

**Біржа:** Binance (Spot Market)

## 2. Функціональні вимоги

### 2.1. Модуль конфігурації (Configurator)

#### 2.1.1. Вибір базової монети:
- Користувач повинен мати можливість вказати "базову" монету, яка буде слугувати початковою та кінцевою точкою в арбітражному циклі.
- Ця конфігурація зберігається у файлі `config.json`.
- **Приклад `config.json`:**
  ```json
  {
    "base_currency": "USDT"
  }
  ```

#### 2.1.2. Вибір монет для моніторингу:
- Користувач повинен мати можливість вказати список криптовалют, які бот буде відстежувати для пошуку арбітражних можливостей.
- Список монет зберігається у файлі `monitored_coins.json`.
- **Приклад `monitored_coins.json`:**
  ```json
  {
    "coins_to_monitor": ["BTC", "ETH", "BNB", "SOL", "XRP", "ADA"]
  }
  ```

### 2.2. Модуль пошуку циклів (Cycle Finder)

#### 2.2.1. Генерація торгових пар: 
- На основі базової монети та списку монет для моніторингу, модуль повинен автоматично згенерувати всі можливі торгові пари, які існують на Binance.

#### 2.2.2. Побудова арбітражних циклів: 
- Модуль повинен ідентифікувати всі унікальні трикутні цикли, які можна побудувати з доступних пар.
- **Приклад циклу:** USDT → BTC → ETH → USDT.

#### 2.2.3. Збереження результатів:
- Усі знайдені цикли повинні бути збережені у файлі `possible_cycles.json` для структурованого доступу.
- **Приклад `possible_cycles.json`:**
  ```json
  [
    ["USDT", "BTC", "ETH", "USDT"],
    ["USDT", "BNB", "SOL", "USDT"],
    ["USDT", "XRP", "ADA", "USDT"]
  ]
  ```
- Також, для зручності читання людиною, список циклів дублюється у файл `possible_cycles.txt`.
- **Приклад `possible_cycles.txt`:**
  ```
  USDT -> BTC -> ETH -> USDT
  USDT -> BNB -> SOL -> USDT
  USDT -> XRP -> ADA -> USDT
  ```

### 2.3. Модуль розрахунку прибутковості (Profit Calculator)

#### 2.3.1. Отримання даних: 
- Модуль повинен підключатися до API Binance через WebSocket для отримання ринкових даних (ціни bid/ask) у реальному часі для всіх пар, що беруть участь у знайдених циклах.

#### 2.3.2. Розрахунок прибутковості: 
- Для кожного циклу з `possible_cycles.json` модуль безперервно виконує розрахунок потенційного прибутку за наступним алгоритмом:
  1. Імітація купівлі монети №2 за монету №1 (базову).
  2. Імітація купівлі монети №3 за монету №2.
  3. Імітація продажу монети №3 за монету №1 (базову).
- **Важливо:** Розрахунок повинен обов'язково враховувати торгову комісію Binance (з урахуванням можливої знижки при оплаті в BNB).

#### 2.3.3. Умова прибутковості: 
- Розрахунок вважається позитивним, якщо кінцева кількість базової монети більша за початкову.
  `Кінцева_сума > Початкова_сума`

### 2.4. Модуль звітності (Logger)

#### 2.4.1. Логування позитивних циклів:
- Якщо Profit Calculator виявляє прибутковий цикл, вся інформація про цю можливість повинна бути негайно записана в окремий файл `profitable_opportunities.log`.
- Запис повинен містити:
  - Часову мітку (timestamp) у форматі `YYYY-MM-DD HH:MM:SS.ms`.
  - Повний арбітражний цикл (наприклад, `USDT -> BTC -> ETH -> USDT`).
  - Ціни на кожному етапі угоди.
  - Розрахований відсоток прибутку.
- **Приклад запису в `profitable_opportunities.log`:**
  ```
  [2025-09-13 19:35:10.123] SUCCESS!
  Cycle: USDT -> BTC -> ETH -> USDT
  Step 1: Buy BTC with USDT at price 51000.00
  Step 2: Buy ETH with BTC at price 0.055
  Step 3: Sell ETH for USDT at price 2850.50
  PROFIT: 0.35%
  ---
  ```

## 3. Нефункціональні вимоги

- **Продуктивність:** Бот повинен обробляти ринкові дані з мінімальною затримкою. Використання WebSockets є пріоритетним над REST API запитами для отримання цін.
- **Надійність:** Бот повинен мати механізми обробки помилок (наприклад, втрата з'єднання з API) та намагатися відновити роботу автоматично.
- **Конфігурованість:** Всі ключові параметри (API ключі, поріг прибутковості, комісії) повинні бути винесені в конфігураційні файли або змінні середовища, а не "зашиті" в код.
- **Безпека:** API ключі не повинні зберігатися у вихідному коді. Рекомендується використовувати змінні середовища або зашифрований файл конфігурації.

## 4. Стек технологій та бібліотек

- **Мова програмування:** Python 3.9+
- **Основні бібліотеки:**
  - `python-binance`: для взаємодії з REST API Binance.
  - `websockets`: для отримання даних у реальному часі.
  - `asyncio`: для асинхронної обробки даних та підвищення продуктивності.
- **Формати даних:** JSON, TXT.
